---
layout: post
title:  "Teorema CAP"
date:   2017-07-16 13:00:00 -0300
categories: database
summary: "Sobre bancos de dados, benefícios e problemas de alguns modelos"
tags:
  - database
---
Você já ouviu falar sobre o teorema CAP?

++++
<iframe width="560" height="315" src="https://www.youtube.com/embed/GBZ-bGDhGpg" frameborder="0" allowfullscreen></iframe>
++++

Não... não esse CAP. Vamos a https://pt.wikipedia.org/wiki/Teorema_CAP[Wikipedia]:

""
Teorema do CAP, também chamado de http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf[Teorema de Brewer], afirma que é impossível que o armazenamento de dados distribuído forneça simultaneamente mais de duas das três garantias seguintes: 

* *Consistência (Consistency)*: Cada leitura recebe a escrita mais recente ou um erro
* *Disponibilidade (Availability*): Cada pedido recebe uma resposta (sem erro) - sem garantia de que contém a escrita mais recente
* *Tolerância a particionamentos (Partition tolerance)*: O sistema continua a funcionar apesar de um número arbitrário de mensagens serem descartadas (ou atrasadas) pela rede entre nós

Nenhum sistema distribuído está protegido contra falhas de rede, portanto, a *partição* geralmente deve ser tolerada. Na presença de partições, são dadas duas opções: *consistência* ou *disponibilidade*. 

Ao escolher *consistência* em relação à disponibilidade, o sistema retornará um erro ou um tempo limite se informações específicas não puderem ser garantidamente actualizadas devido à sua partilha na rede. 

Ao escolher *disponibilidade* sobre consistência, o sistema sempre processará a consulta e tentará retornar a versão disponível mais recente da informação, mesmo que não possa garantir que ela esteja atualizada devido às partições.
""

*Versão super resumida*: bancos de dados só podem escolher 2 dos 3 elementos. É matemáticamente impossível ter os 3.

'''

### E onde os bancos de dados atuais se encaixam?

Vamos à figura:

image::http://www.mysoftkey.com/wp-content/uploads/2016/09/cap-theorem-triangle.png[align=center]


* *_Consistency_ + _Availability_*: como exemplos temos bancos de dados relacionais (Oracle, MySql, Postgre, MS SQL Server, etc). Tendo CA, eles não tem _Partition Tolerance_. Eles podem ter replicação, mas não partição. E aqui temos toda a parte de transação, _locks_ de banco, etc

O banco de dados grafo https://neo4j.com[neo4j] também está nesse quadrante, assim como o https://www.torodb.com[ToroDB].

* *_Consistency_ + _Partition Tolerance_*: a maioria dos bancos noSql estão aqui. Eles podem ser chave-valor (https://redis.io/[Redis]), tabulares (https://hbase.apache.org[hbase] do http://hadoop.apache.org/[Hadoop]) e orientados a documento (https://www.mongodb.com/[mongo]). 

Mesmo sacrificando disponibilidade isso não deveria ser um problema se usado corretamente. Ex: fazer a aplicação conhecer todos os membros _cluster_, mudar o nodo em caso do atual falhar (e remover ele da lista de nodos válidos).

* *_Partition Tolerance_ + _Availability_*: aqui o mais conhecido é o http://cassandra.apache.org/[Cassandra], usado pelo netflix. Não tenho experiencia com bancos PA, mas do que eu pude ver você pode selecionar a consistência durante a operação. Ex: views do youtube - não teria muito problema se retornasse 1004 ou 1007 _views_.

### Considerações

* +++<strike>+++RDBMS não fazem uso de computação distribuída, limitando a escalabilidade por _hardware_+++</strike>+++;
** Update: bancos como https://cloud.google.com/spanner/[Google Cloud Spanner], https://www.cockroachlabs.com/[CockroachDB], https://aws.amazon.com/rds/auror[Amazon Aurora] são exceções a essa regra (tks *alanhoff* do http://nodebr.slack.com[nodebr])
* As vantagens dos bancos noSql vão alem da sintaxe, já que eles fazem uso de partição / cluster;
* Bancos como https://www.mongodb.com/[mongodb] não fazem uso de transação (_commit_ / _rollback_). E nem possuem isso no _roadmap_. Para melhor uso desses bancos, pode ser usado um _approach_ de https://www.youtube.com/watch?v=ATWEXZkYgek[_Event Sourcing_], onde não tenha alteração / exclusão de dados. Além de _event sourcing_ ainda tem controles de consistência otimistas, tipo o que os http://couchdb.apache.org/[_Couch_]-_like_ utilizam.
* Divisão de _hardware_ é algo a ser considerado para melhor performance. Ex: em bancos como https://hbase.apache.org[hbase], é melhor ter múltiplos HDs menores do que um grande SSD, para paralelismo de IO;
* O modelo de dados pode ser implementado em diferentes bases do CAP, como é o caso de bancos de dados tabulares: CA com https://www.vertica.com/[Vertica], CP com https://hbase.apache.org[HBase], PA com http://cassandra.apache.org/[Cassandra].

### Referencias
* http://blog.caelum.com.br/nosql-do-teorema-cap-para-paccl/[NoSQL – Do teorema CAP para P?(A|C):(C|L)]
* https://unrealps.wordpress.com/2010/12/28/o-teorema-cap[O teorema CAP]
* http://www.jrobertoaraujo.com/2017/01/03/teorema-cap[Teorema Cap]
* https://pt.slideshare.net/Celio12/nosql-base-vs-acid-e-teorema-cap[NoSQL, Base VS ACID e Teorema CAP]
* http://www.geati.ifc-camboriu.edu.br/wiki/index.php/Exemplo_explicativo_do_Teorema_CAP[Exemplo explicativo do Teorema CAP]

### Updates
Obrigado especial ao https://twitter.com/PEdrArthur[@PEdrArthur] pelo _review_ e dicas. 

Dúvidas? comentários? Sugestões? Ficou claro o conteúdo? Deixa um comentário aí abaixo.